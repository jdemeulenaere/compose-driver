package com.github.jdemeulenaere.compose.driver

import androidx.compose.runtime.Composable
import androidx.compose.runtime.Composer
import androidx.compose.runtime.currentComposer

/**
 * Resolves a @Composable function by its fully qualified name and returns a lambda that invokes it.
 *
 * Disclaimer: This implementation was fully generated by Gemini and might not be 100% incorrect,
 * but it works for this MVP :-).
 *
 * This implementation supports composables with default parameters by leveraging the JVM signatures
 * generated by the Compose compiler.
 *
 * ### How it works:
 * 1. **Transformed Signature**: The Compose compiler adds extra parameters to @Composable methods:
 *    `fun MyComp(arg: String, $composer: Composer, $changed: Int, $default: Int)`
 * 2. **$default Mask**: The last parameter(s) are bitmasks. If a bit is set to `1` for a given
 *    parameter, the function ignores the passed value and uses the default value defined in the
 *    source code.
 * 3. **Reflection Trick**: We pass `null`/`0` for all regular parameters, but we pass **`-1`** (all
 *    ones) for the `$default` masks. This tells the generated bytecode to use the actual default
 *    values for EVERY parameter.
 */
internal fun fullyQualifiedComposable(name: String): @Composable () -> Unit {
    val lastDotIndex = name.lastIndexOf('.')
    require(lastDotIndex != -1) { "Invalid composable name: $name" }
    val className = name.take(lastDotIndex)
    val methodName = name.substring(lastDotIndex + 1)
    val clazz =
        try {
            Class.forName(className)
        } catch (e: ClassNotFoundException) {
            throw IllegalArgumentException("Class not found: $className", e)
        }

    val method =
        clazz.declaredMethods
            .filter { it.name == methodName }
            .sortedBy { it.parameterCount }
            .firstOrNull { it.parameterTypes.contains(Composer::class.java) }
            ?: throw IllegalArgumentException(
                "Method '$methodName' not found or not a @Composable in $className"
            )

    method.isAccessible = true

    return {
        val params = method.parameterTypes
        val args = arrayOfNulls<Any>(params.size)
        var composerIndex = -1
        for (i in params.indices) {
            if (params[i] == Composer::class.java) {
                composerIndex = i
                args[i] = currentComposer
            } else if (composerIndex != -1 && i > composerIndex) {
                // $changed or $default masks
                if (i == composerIndex + 1) {
                    args[i] = 0 // $changed
                } else {
                    args[i] = -1 // $default mask
                }
            } else {
                // Regular parameter, pass default value for primitive or null
                val type = params[i]
                if (type.isPrimitive) {
                    args[i] =
                        when (type) {
                            java.lang.Integer.TYPE -> 0
                            java.lang.Long.TYPE -> 0L
                            java.lang.Float.TYPE -> 0f
                            java.lang.Double.TYPE -> 0.0
                            java.lang.Boolean.TYPE -> false
                            java.lang.Byte.TYPE -> 0.toByte()
                            java.lang.Short.TYPE -> 0.toShort()
                            java.lang.Character.TYPE -> '\u0000'
                            else -> 0
                        }
                } else {
                    args[i] = null
                }
            }
        }
        method.invoke(null, *args)
    }
}
